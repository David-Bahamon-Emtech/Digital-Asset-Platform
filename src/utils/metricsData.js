import { subMonths, isWithinInterval, compareAsc, compareDesc } from 'date-fns';

const defaultAlertThreshold = 100;

export const detailedDummyReserveData = {
  'cp-acme-01': { circulationChange: 500000 + Math.floor(Math.random() * 100000 - 50000), ratio: 100.0, requirement: 100, lastAudit: `2025-04-01`, auditor: 'KPMG (Asset Verification)', composition: [ { name: 'Underlying Commercial Paper Notes (Acme Corp)', percent: 100.0 } ], accounts: [ { institution: 'Bank of New York Mellon', type: 'Custodial Account (CP Notes)', balance: '50,000,000 USD Face Value', updated: 'Yesterday', status: 'Active' }, { institution: 'Acme Corp Issuing SPV', type: 'Issuance Vehicle Ledger', balance: '50,000,000 ACP Tokens', updated: 'Real-time', status: 'Active' }, { institution: 'Computershare (Paying Agent)', type: 'Paying Agent Account', balance: 'Variable (Cash for Maturity)', updated: 'Daily', status: 'Active' }, { institution: 'PolygonScan (Auditor View)', type: 'On-Chain Supply', balance: '45,000,000 ACP', updated: 'Real-time', status: 'Verified' }, { institution: 'Internal Control Ledger', type: 'Reconciliation Account', balance: 'Match Verified', updated: 'Today', status: 'Active' }, { institution: 'Legal Docs Depository', type: 'Note Agreements', balance: 'Filed', updated: 'Origination Date', status: 'Active' }, ] },
  'mmf-usd-01': { circulationChange: 1200000 + Math.floor(Math.random() * 200000 - 100000), ratio: 100.0, requirement: 100, lastAudit: `2025-04-15`, auditor: 'Stable Investments Fund Admin', composition: [ { name: 'Shares in Underlying MMF (e.g., Fidelity Govt MMF)', percent: 100.0 } ], accounts: [ { institution: 'Fidelity Investments', type: 'Underlying MMF Holding', balance: '250,000,000 Shares', updated: 'Today (T+1 NAV)', status: 'Active' }, { institution: 'Coinbase Custody', type: 'Token Custody', balance: '250,000,000 MMFUSD', updated: 'Real-time', status: 'Active' }, { institution: 'Stable Investments LLC', type: 'Operational Account', balance: '50,000 USDC', updated: 'Today', status: 'Active' }, { institution: 'Etherscan (Auditor View)', type: 'On-Chain Supply', balance: '240,500,000 MMFUSD', updated: 'Real-time', status: 'Verified' }, { institution: 'NAV Calculation Agent', type: 'Valuation Feed', balance: '$1.0000 per Share', updated: 'Today', status: 'Active' }, { institution: 'Redemption Queue', type: 'Order Book', balance: '~500k MMFUSD', updated: 'Hourly', status: 'Active' }, ] },
  'xagc-01': { circulationChange: -50000 + Math.floor(Math.random() * 10000 - 5000), ratio: 100.2 + (Math.random() * 3 - 1.5), requirement: 100, lastAudit: `2025-03-10`, auditor: 'Brink\'s Global Services', composition: [ { name: 'Physical Silver Bullion (LBMA Good Delivery)', percent: 100.0 } ], accounts: [ { institution: 'Brink\'s Zurich Vault', type: 'Allocated Silver Storage', balance: '27,322.5 Kg (Approx)', updated: 'Last Audit', status: 'Verified' }, { institution: 'Precious Metals Inc.', type: 'Inventory Ledger', balance: '1,000,000 XAGC Units', updated: 'Real-time', status: 'Active' }, { institution: 'StellarExpert (Auditor View)', type: 'On-Chain Supply', balance: '850,000 XAGC', updated: 'Real-time', status: 'Verified' }, { institution: 'Insurance Provider (Lloyds)', type: 'Policy Record', balance: 'Coverage Verified', updated: 'Quarterly', status: 'Active' }, { institution: 'Minting Control Address', type: 'Issuance Wallet', balance: '150,000 XAGC', updated: 'Real-time', status: 'Secure' }, { institution: 'Refining Partner', type: 'Source Verification', balance: 'Certified', updated: 'Batch Date', status: 'Active' }, ] },
  'oil-wti-01': { circulationChange: 20000 + Math.floor(Math.random() * 5000 - 2500), ratio: 100.0 + (Math.random() * 2 - 1), requirement: 100, lastAudit: `2025-04-05`, auditor: 'SGS Group', composition: [ { name: 'WTI Crude Oil (Physical Barrels)', percent: 100.0 } ], accounts: [ { institution: 'Enterprise Products Partners (Cushing Storage)', type: 'Allocated Storage', balance: '500,000 Barrels', updated: 'Weekly Report', status: 'Verified' }, { institution: 'Energy Tokens Ltd.', type: 'Token Ledger', balance: '500,000 WTOIL', updated: 'Real-time', status: 'Active' }, { institution: 'PolygonScan (Auditor View)', type: 'On-Chain Supply', balance: '480,000 WTOIL', updated: 'Real-time', status: 'Verified' }, { institution: 'NYMEX/CME Group', type: 'Futures Hedging Account', balance: 'Variable', updated: 'Daily', status: 'Active' }, { institution: 'Logistics Partner (Pipeline Co.)', type: 'Transport Records', balance: 'In Transit: 0 bbl', updated: 'Daily', status: 'Active' }, { institution: 'Environmental Compliance Cert.', type: 'Permit Record', balance: 'Valid', updated: 'Annually', status: 'Active' }, ] },
  'cc-verra-01': { circulationChange: -100000 + Math.floor(Math.random() * 20000 - 10000), ratio: 100.0, requirement: 100, lastAudit: `2025-01-20`, auditor: 'Verra Registry API / Internal Audit', composition: [ { name: 'Verified Carbon Units (VCUs) on Verra Registry', percent: 100.0 } ], accounts: [ { institution: 'Verra Registry', type: 'Master Holding Account', balance: '10,000,000 VCUs', updated: 'Daily Sync', status: 'Active' }, { institution: 'Green Future Tokens', type: 'Token Issuance Ledger', balance: '10,000,000 VCC', updated: 'Real-time', status: 'Active' }, { institution: 'Hedera Hashgraph (Auditor View)', type: 'On-Chain Supply', balance: '9,500,000 VCC', updated: 'Real-time', status: 'Verified' }, { institution: 'Retirement Wallet', type: 'Burned/Retired Credits', balance: '500,000 VCC', updated: 'As Retired', status: 'Retired' }, { institution: 'Project Developer Source', type: 'Origination Verification', balance: 'Verified Projects', updated: 'Project Date', status: 'Active' }, { institution: 'Marketplace Listing', type: 'Available for Sale', balance: '~1M VCC', updated: 'Hourly', status: 'Active' }, ] }
};

// *** REMOVED incorrect duplicate placeholder definition ***
// export const generateReserveHistory = (asset, detailedReserveDataMap) => { /* ... */ };

export const getReserveComposition = (asset, detailedReserveDataMap) => {
  console.log(`[getReserveComposition] Called for asset ID: ${asset?.id}, Symbol: ${asset?.symbol}`);
  if (!asset) { console.warn("[getReserveComposition] No asset provided."); return []; }
  const details = detailedReserveDataMap[asset.id];
  console.log(`[getReserveComposition] Found details in map for ${asset.id}:`, details);
  if (details && Array.isArray(details.composition)) {
    console.log(`[getReserveComposition] Found composition array in details for ${asset.id}:`, details.composition);
    let totalPercent = details.composition.reduce((sum, item) => sum + (item.percent || 0), 0);
    let compositionToReturn = details.composition;
    if (totalPercent > 0 && Math.abs(totalPercent - 100) > 0.1) {
        console.log(`[getReserveComposition] Normalizing composition for ${asset.id}. Original total: ${totalPercent}`);
        compositionToReturn = details.composition.map(item => ({...item, percent: ((item.percent || 0) / totalPercent) * 100 }));
    }
    console.log(`[getReserveComposition] Returning composition for predefined asset ${asset.id}:`, compositionToReturn);
    return compositionToReturn;
  } else { console.log(`[getReserveComposition] No composition array found in details map for ${asset.id}. Checking if wizard asset.`); }
  if (asset.isWizardIssued) {
    console.log(`[getReserveComposition] Asset ${asset.id} is wizard issued.`);
    const isBacked = asset.wizardData?.reserveDetails?.isBackedAsset || false;
    if (isBacked) { const backingType = asset.wizardData?.reserveDetails?.backingType || 'Unknown'; const wizardComposition = [{ name: `User Defined Backing (${backingType})`, percent: 100.0 }]; console.log(`[getReserveComposition] Returning wizard composition (backed):`, wizardComposition); return wizardComposition; }
    else { const wizardComposition = [{ name: 'Not Asset Backed', percent: 100.0 }]; console.log(`[getReserveComposition] Returning wizard composition (not backed):`, wizardComposition); return wizardComposition; }
  }
  console.warn(`[getReserveComposition] Returning empty array for asset ${asset.id}.`);
  return [];
};

export const getAlertThreshold = (asset) => {
  if (!asset) return defaultAlertThreshold; let threshold = defaultAlertThreshold; const stableClasses = ['Stablecoin', 'CBDC', 'Security: MMF']; const backedClasses = ['Commodity: Precious Metal', 'Commodity: Energy', 'Carbon Credit', 'Security: CP', 'Security: Bond']; if (stableClasses.includes(asset.assetClass) || backedClasses.includes(asset.assetClass)) { threshold = 100; } else if (asset.isWizardIssued && asset.wizardData?.reserveDetails?.isBackedAsset) { threshold = 100; } else if (asset.assetClass === 'Cryptocurrency' || !asset.assetClass) { threshold = 0; } return threshold;
};

export const generateCirculationHistory = (asset, tokenHistory = []) => {
    console.log(`Generating BACKWARD circulation history for: ${asset?.symbol}`);
    if (!asset || typeof asset.balance !== 'number') { console.error(`[generateCirculationHistory] Invalid asset or balance for ${asset?.symbol}`); return []; }
    const now = new Date(); const twelveMonthsAgo = subMonths(now, 12); let effectiveStartDate = twelveMonthsAgo; let initialIssuanceAmount = 0; let isWizardStartPoint = false;
    if (asset.isWizardIssued && asset.issuanceTimestamp) { const issueDate = new Date(asset.issuanceTimestamp); initialIssuanceAmount = asset.wizardData?.supplyDetails?.initialSupply || 0; if (issueDate > effectiveStartDate) { effectiveStartDate = issueDate; isWizardStartPoint = true; } }
    console.log(`[generateCirculationHistory] Effective Start Date: ${effectiveStartDate.toISOString()}`);
    const symbolPattern = new RegExp(`\\b${asset.symbol}\\b`); const relevantActions = ['Mint', 'Burn', 'Issue', 'Redeem/Swap'];
    const recentRelevantHistory = tokenHistory .filter(entry => { const eventDate = new Date(entry.timestamp); if (eventDate < effectiveStartDate) return false; if (!relevantActions.includes(entry.actionType)) return false; return symbolPattern.test(entry.details || ''); }) .sort((a, b) => compareDesc(a.timestamp, b.timestamp));
    console.log(`[CirculationHistory] Relevant history count after date/type filter: ${recentRelevantHistory.length}`);
    const historyPoints = []; let balanceBeforeEvent = asset.balance;
    historyPoints.push({ date: now, balance: asset.balance, eventType: null, amount: null });
    recentRelevantHistory.forEach((entry, index) => { const eventDate = new Date(entry.timestamp); const amountMatch = entry.details?.match(/([0-9,]+(\.\d+)?)\s+/); const amount = amountMatch ? parseFloat(amountMatch[1].replace(/,/g, '')) : 0; let eventType = entry.actionType; let changeAmount = 0; if (entry.actionType === 'Mint') { changeAmount = amount; } else if (entry.actionType === 'Burn') { changeAmount = -amount; } else if (entry.actionType === 'Issue' && asset.isWizardIssued) { changeAmount = amount; eventType = 'Issue'; } else if (entry.actionType === 'Redeem/Swap') { if (entry.details?.startsWith(`Swapped`) && symbolPattern.test(entry.details.split('for ~')[0])) { changeAmount = -amount; eventType = 'Swap Out'; } else if (entry.details?.includes(`for ~`) && symbolPattern.test(entry.details.split('for ~')[1])) { const receivedAmountMatch = entry.details?.match(/for ~([0-9,]+(\.\d+)?)/); changeAmount = receivedAmountMatch ? parseFloat(receivedAmountMatch[1].replace(/,/g, '')) : 0; eventType = 'Swap In'; } else if (entry.details?.startsWith('Redeemed')) { changeAmount = -amount; eventType = 'Redeem'; } else { changeAmount = 0; eventType = null; } } else { changeAmount = 0; eventType = null; } if (changeAmount !== 0 || (eventType === 'Issue' && isWizardStartPoint && eventDate.getTime() === effectiveStartDate.getTime())) { if (changeAmount !== 0) { historyPoints.push({ date: eventDate, balance: balanceBeforeEvent, eventType: eventType, amount: Math.abs(amount) }); balanceBeforeEvent -= changeAmount; balanceBeforeEvent = Math.max(0, balanceBeforeEvent); } } });
    const earliestEventDate = historyPoints[historyPoints.length - 1]?.date; if (!earliestEventDate || earliestEventDate > effectiveStartDate) { const startEventType = isWizardStartPoint ? 'Issue' : null; const startAmount = isWizardStartPoint ? initialIssuanceAmount : null; historyPoints.push({ date: effectiveStartDate, balance: balanceBeforeEvent, eventType: startEventType, amount: startAmount }); } else { historyPoints[historyPoints.length - 1].balance = balanceBeforeEvent; }
    const finalData = historyPoints.sort((a, b) => compareAsc(a.date, b.date));
    console.log(`[CirculationHistory] Final generated data for ${asset.symbol}:`, finalData.length); return finalData;
};
